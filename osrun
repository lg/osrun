#!/bin/ash
#shellcheck shell=dash disable=SC3036,SC3048,SC2002,SC3060
set -o errexit -o noclobber -o nounset -o pipefail

# Parse commandline arguments
usage() {
  echo -e \
    "Usage: osrun [flags] '<command>'\n" \
    "Short-lived containerized Windows instances\n" \
    "\n" \
    "  -h --help: Display this help\n" \
    "  -v --verbose: Verbose mode (default: $VERBOSE)\n" \
    "\n" \
    "Install\n" \
    "  -k --keep: Keep the installation ISOs after successful provisioning (default: $KEEP_INSTALL_FILES)\n" \
    "\n" \
    "Run\n" \
    "  -p --pause: Do not close the VM after the command finishes (default: $PAUSE)\n" \
    "  -n --new-snapshot <name>: Generate a new snapshot after the command finishes\n" \
    "  -s --use-snapshot <name>: Restore from the specified snapshot (default: $USE_SNAPSHOT_NAME)\n" \
    1>&2

  exit 1
}; [ $# -eq 0 ] && usage

VERBOSE=false; PAUSE=false; KEEP_INSTALL_FILES=false; NEW_SNAPSHOT_NAME=""; USE_SNAPSHOT_NAME="provisioned"
params="$(getopt -o "vhpkn:s:" -l verbose,help,pause,keep,new-snapshot,use-snapshot -n "osrun" -- "$@")"
eval set -- "$params"
while true; do case "$1" in
  -k|--keep) KEEP_INSTALL_FILES=true; shift ;;
  -v|--verbose) VERBOSE=true; shift ;;
  -p|--pause) PAUSE=true; shift ;;
  -n|--new-snapshot) NEW_SNAPSHOT_NAME="$2"; shift 2 ;;
  -s|--use-snapshot) USE_SNAPSHOT_NAME="$2"; shift 2 ;;
  --) shift; break ;;
  *) usage ;;
esac; done

RUN_COMMAND="$*"

if [ -e "/cache/not-forwarded" ]; then
  echo -e "\033[33;49mWARNING: /cache is not mounted. Windows will need to be rebuilt every time. This is not" \
    "recommended! Forward this path to the local machine, ex: \`-v \$(pwd)/cache:/cache\`\033[0m" > /dev/stderr
fi

# Windows 11 from May 2023 from https://uupdump.net and as backup https://uup.rg-adguard.net
UUPS_URL=${UUPS_URL:-"http://uupdump.net/get.php?id=3a34d712-ee6f-46fa-991a-e7d9520c16fc&pack=en-us&edition=professional&aria2=2;https://uup.rg-adguard.net/api/GetFiles?id=3a34d712-ee6f-46fa-991a-e7d9520c16fc&lang=en-us&edition=professional&txt=yes"}
UUPDUMP_CONVERT_SCRIPT_URL=${UUPDUMP_CONVERT_SCRIPT_URL:-"https://github.com/uup-dump/converter/raw/073071a0003a755233c2fa74c7b6173cd7075ed7/convert.sh"}

INSTALL_MEMORY_GB=${INSTALL_MEMORY_GB:-8}
RUN_MEMORY_GB=${RUN_MEMORY_GB:-4}
INIT_SCRIPTS_PATH=${INIT_SCRIPTS_PATH:-"./win11-init"}
STEP_FILES=${STEP_FILES:-"autounattend.xml boot-0.ps1 boot-1.ps1"}

# Everything logged to /tmp/qemu-status/status.txt or in Windows with `echo hello >> \\10.0.2.4\qemu\status.txt` will be
# printed out to stdout
mkdir -p /tmp/qemu-status
touch /tmp/qemu-status/status.txt
tail -f /tmp/qemu-status/status.txt &

# Start the novnc webserver (basically just an http server and a websocket proxy to qemu's vnc websocket)
novnc_server --listen 8000 --vnc 127.0.0.1:5950 > /dev/null 2>&1 &

start_qemu() {
  KVM_PARAM=",accel=kvm"; CPU_PARAM="-cpu host,hv_stimer,hv_time,hv_synic,hv_vpindex"
  if [ ! -e /dev/kvm ]; then
    echo -e "\033[33;49mKVM acceleration not found. Ensure you're using --device=/dev/kvm with docker when on Linux." \
      "Virtualization will be very slow.\033[0m" > /dev/stderr
    KVM_PARAM=""; CPU_PARAM="-accel tcg"
  fi

  QEMU_OPTS=""
  while getopts 'rm:o:v:' OPTION; do case "$OPTION" in
    m) MEMORY_GB="$OPTARG" ;;
    o) QEMU_OPTS="$OPTARG" ;;
    v) VOLUME_PATH="$OPTARG" ;;
    *) exit 1 ;;
  esac; done

  # shellcheck disable=SC2086
  qemu-system-x86_64 \
    -name osrun \
    \
    -machine "type=q35$KVM_PARAM" \
    -rtc clock=host,base=localtime \
    $CPU_PARAM \
    -smp "$(grep -c ^processor /proc/cpuinfo)" \
    -m "${MEMORY_GB:-8}G" \
    -vga virtio \
    -device e1000,netdev=user.0 \
    -netdev user,id=user.0,smb=/tmp/qemu-status \
    \
    -drive "file=$VOLUME_PATH,media=disk,cache=unsafe,if=ide,format=qcow2,discard=unmap" \
    $QEMU_OPTS \
    \
    -device qemu-xhci \
    -device usb-tablet,bus=usb-bus.0 \
    \
    -device virtio-serial \
    -chardev socket,websocket=on,host=0.0.0.0,port=44444,server=on,wait=off,id=qga0 \
    -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 \
    \
    -vnc 0.0.0.0:50 \
    -monitor tcp:0.0.0.0:55556,server=on,wait=off \
    &
}

agent_command() {
  local val; local execute; local arguments
  execute="$1"; arguments="${2:-"{}"}"
  val=$(echo "{\"execute\": \"$execute\", \"arguments\": $arguments}" \
    | while ! websocat -b -n -1 ws://127.0.0.1:44444/ 2>/dev/null; do sleep 0.1; done)

  if [ "$(echo "$val" | jq -r '.error')" != null ]; then
    echo -e "\033[31;49mError running $execute$([ "$arguments" != "{}" ] && echo " ($arguments)"): $(\
      echo "$val" | jq -r '.error.desc')\033[0m"
    exit 1
  fi
  echo "$val" | jq -r '.return'
}

provision_win11() {
  mkdir -p /root/.aria2/ ; echo -e "console-log-level=warn\nmax-connection-per-server=16\nsplit=16\n\
    max-concurrent-downloads=5\ncontinue\nremote-time\nauto-file-renaming=false\n" > "/root/.aria2/aria2.conf"

  if [ ! -e /cache/win11-clean.iso ]; then
    echo -e "\033[32;49;1mDownloading Windows 11 from Windows Update\033[0m"
    mkdir -p /tmp/win11

    echo -e "\033[32;49mGetting file list\033[0m"
    #shellcheck disable=SC2086
    aria2c --dir /tmp/win11 --out aria-script --allow-overwrite=true ${UUPS_URL//;/ }

    echo -e "\033[32;49mDownloading files from Windows Update\033[0m"
    aria2c --dir /tmp/win11 --input-file /tmp/win11/aria-script

    echo -e "\033[32;49mConverting updates to ISO\033[0m"
    aria2c --dir /tmp/win11 --out convert.sh --allow-overwrite=true "$UUPDUMP_CONVERT_SCRIPT_URL"
    chmod +x /tmp/win11/convert.sh

    echo -e "\033[32;49;1mBuilding Windows 11 ISO\033[0m"
    /tmp/win11/convert.sh wim /tmp/win11 0
    mv /*PROFESSIONAL_X64_EN-US.ISO /cache/win11-clean.iso
    rm -rf /tmp/win11
  else
    echo -e "\033[32;32mSkipping, ISO already exists\033[0m"
  fi

  echo -e "\033[32;49;1mGenerating ISO for autounattend.xml\033[0m"
  genisoimage -joliet -o "/tmp/autounattend.iso" -quiet /win11-init/autounattend.xml

  echo -e "\033[32;32;1mInstalling Windows (Logs redirected here, noVNC at: http://localhost:8000/vnc.html)\033[0m"
  mkdir -p /tmp/qemu-status/win11-init
  cp /win11-init/* /tmp/qemu-status/win11-init/

  # The Windows installation will reboot a variety of times. This will keep the hard drive state for each reboot so you
  # can edit the scripts and re-run the installation without having to start from scratch.
  STEP=-1
  for STEP_FILENAME in $STEP_FILES; do
    STEP=$((STEP+1))
    STEP_HASH=$(echo "${PREV_STEP_HASH:-""}$(cat "$INIT_SCRIPTS_PATH/$STEP_FILENAME")" | md5sum | cut -c1-5 )
    STEP_ARTIFACT="/cache/win11-step$STEP-$STEP_HASH.qcow2"
    echo -e "\033[32;32mBooting, will use script $STEP_FILENAME, artifact will be: $STEP_ARTIFACT\033[0m"

    if [ ! -e "$STEP_ARTIFACT" ]; then
      rm -f /cache/win11-step$STEP-*.qcow2          # remove any previous artifacts for this step
      if [ "$STEP" = "0" ]; then
        qemu-img create -f qcow2 -o compression_type=zstd,extended_l2=on,cluster_size=128k -q "$STEP_ARTIFACT" 15G
      else
        qemu-img create -f qcow2 -o backing_file="$PREV_STEP_ARTIFACT",backing_fmt=qcow2,compression_type=zstd,extended_l2=on,cluster_size=128k,preallocation=falloc -q "$STEP_ARTIFACT"
      fi

      trap 'echo -e "\033[31;49mRemoving incomplete artifact $STEP_ARTIFACT\033[0m" ; rm -f "$STEP_ARTIFACT" ; exit 1' SIGINT SIGTERM
      start_qemu -m "$INSTALL_MEMORY_GB" -v "$STEP_ARTIFACT" -o "-action reboot=shutdown -drive file=/cache/win11-clean.iso,media=cdrom -drive file=/tmp/autounattend.iso,media=cdrom"
      wait "$!" || kill -SIGINT $$
      trap - SIGINT SIGTERM
    else
      echo -e "\033[32;32mSkipping, artifact already exists\033[0m"
    fi

    PREV_STEP_ARTIFACT="$STEP_ARTIFACT"
    PREV_STEP_HASH="$STEP_HASH"
  done

  trap 'echo -e "\033[31;49mRemoving /cache/win11.qcow2\033[0m" ; rm -f /cache/win11.qcow2 ; exit 1' SIGINT SIGTERM
  echo -e "\033[32;32;1mCombining artifacts and compressing image\033[0m"
  qemu-img convert -f qcow2 -O qcow2 -c -o compression_type=zstd,extended_l2=on,cluster_size=128k "$PREV_STEP_ARTIFACT" /cache/win11.qcow2

  echo -e "\033[32;32;1mCreating VM snapshot\033[0m"
  rm -f /tmp/qemu-status/lastboot.txt
  start_qemu -m "$RUN_MEMORY_GB" -v /cache/win11.qcow2
  QEMU_PID="$!"

  echo -e "\033[32;32mWaiting for VM to boot and login one last time\033[0m"
  inotifywait -q -e create /tmp/qemu-status > /dev/null
  sleep 10

  echo -e "\033[32;32mCreating 'provisioned' snapshot and waiting for VM to stop\033[0m"
  echo -e "savevm provisioned\nq" | nc 127.0.0.1 55556
  wait "$QEMU_PID" || kill -SIGINT $$

  echo -e "\033[32;32;1mWindows installation complete\033[0m"
  trap - SIGINT SIGTERM
  ! $KEEP_INSTALL_FILES && rm -f /cache/win11-*
}

if [ ! -e /cache/win11.qcow2 ]; then
  echo -e "\033[32;49;1mWindows 11 disk image is missing, going to install it now\033[0m"
  provision_win11
fi

# The command is written to /tmp/qemu-status/run.cmd such that we don't need to worry about escaping quotes and such.
# We use the "provisioned" (by default) snapshot stored in the qcow2 file to avoid having to wait for Windows to boot.
$VERBOSE && echo -e "\033[32;49;1mRunning \`${RUN_COMMAND//\\/\\\\}\` (Output redirected here, noVNC at http://localhost:8000/vnc.html, use --pause to not exit)\033[0m\033[0m"
$VERBOSE && echo -e "\033[32;49mRestoring snapshot '$USE_SNAPSHOT_NAME'\033[0m"
echo -e "@ECHO OFF\nECHO OFF\n" > /tmp/qemu-status/run.cmd
echo "$RUN_COMMAND" >> /tmp/qemu-status/run.cmd
start_qemu -m "$RUN_MEMORY_GB" -o "-loadvm $USE_SNAPSHOT_NAME" -v /cache/win11.qcow2

# Since we resume a snapshot, we need to update the clock. Note we wait for a 'done' file to be created in the shared
# network drive to signal that a command has completed.
mkdir -p /tmp/qemu-status/done
agent_command guest-exec "{'path': 'cmd', 'arg': ['/c', 'powershell Set-Date \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\" & \
  echo done > //10.0.2.4/qemu/done/done.txt']}" > /dev/null
inotifywait -q -e create /tmp/qemu-status/done > /dev/null
rm -f /tmp/qemu-status/done/done.txt

$VERBOSE && echo -e "\033[32;49mRunning command\033[0m"
touch /tmp/qemu-status/out.txt
inotifywait -q -e create /tmp/qemu-status/done > /dev/null &
DONE_WATCHER_PID=$!
EXEC_START=$(agent_command guest-exec '{"path": "cmd",
  "arg": ["/c", "//10.0.2.4/qemu/run.cmd >>//10.0.2.4/qemu/out.txt 2>&1 & echo done > //10.0.2.4/qemu/done/done.txt"]}')
PROCESS_PID=$(echo "$EXEC_START" | jq -r '.pid')

# Since inotifywait was launched asynchronously, use the pid (when terminated) as the signal for `tail` below to end.
# This tail displays the output of the command.
$VERBOSE && echo -e "\033[32;49mWaiting for command to complete\033[0m"
tail -n +0 -f /tmp/qemu-status/out.txt --pid "$DONE_WATCHER_PID"

while true; do  # also ensure the pid ends (so we get the exit code)
  EXEC_STATUS=$(agent_command guest-exec-status '{"pid": '"$PROCESS_PID"'}')
  [ "$(echo "$EXEC_STATUS" | jq -r '.exited')" = "true" ] && break
  sleep 0.1
done
$PAUSE && echo -e "\033[32;49mPausing as requested (noVNC at http://localhost:8000/vnc.html, press ENTER to exit)\033[0m" && read -r

# Optionally create a new snapshot
if [ "$NEW_SNAPSHOT_NAME" != "" ]; then
  $VERBOSE && echo -e "\033[32;49;1mCreating snapshot '$NEW_SNAPSHOT_NAME'\033[0m"
  echo -e "savevm $NEW_SNAPSHOT_NAME\nq" | nc 127.0.0.1 55556
fi

# for faster docker shutdown, intentionally not cleaning up: qemu and the /tmp/qemu-status files
exit "$(echo "$EXEC_STATUS" | jq -r '.exitcode')"
